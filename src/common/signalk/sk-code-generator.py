#!/usr/bin/env python
#     __  __     ______     ______     __  __
#    /\ \/ /    /\  == \   /\  __ \   /\_\_\_\
#    \ \  _"-.  \ \  __<   \ \ \/\ \  \/_/\_\/_
#     \ \_\ \_\  \ \_____\  \ \_____\   /\_\/\_\
#       \/_/\/_/   \/_____/   \/_____/   \/_/\/_/
#
#  The MIT License
#
#  Copyright (c) 2017 Thomas Sarlandie thomas@sarlandie.net
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.

import argparse
import json
import os
import datetime
import sys

class SKModel(object):
    @staticmethod
    def model_from_json(json):
        model = SKModel([])

        vesselKeysJson = json['vesselKeys']
        for keyJson in vesselKeysJson:
            unit = None
            if 'unit' in keyJson:
                unit = keyJson['unit']
            key = SKKey(keyJson['path'], keyJson['type'], unit, keyJson['description'])
            model.keys.append(key)

        return model

    def __init__(self, keys):
        self.keys = keys


class SKKey(object):
    def __init__(self, path, skType, unit, description):
        self.path = path
        self.skType = skType
        self.unit = unit
        self.description = description

    def getPath(self):
        return self.path

    def getSKType(self):
        return self.skType

    def getUnit(self):
        return self.unit

    def getDescription(self):
        return self.description

    def isIndexed(self):
        return "%%" in self.path

    def camelCasedPath(self):
        elements = self.path.split(".")

        camelPath = ""
        for e in elements:
            if e != "%%":
                camelPath = camelPath + e[0].upper() + e[1:]
        return camelPath

    def enumKey(self):
        return "SKPath" + self.camelCasedPath()

    def visitorName(self):
        return "visitSK" + self.camelCasedPath();

    def cType(self):
        if self.skType == 'numberValue':
            return 'double'
        if self.skType == 'attitudeValue':
            return 'SKTypeAttitude'
        if self.skType == 'positionValue':
            return 'SKTypePosition'
        raise ValueError("Invalid SignalK type {}".format(self.skType))

    def cTypeAccessor(self):
        if self.skType == 'numberValue':
            return 'getNumberValue'
        if self.skType == 'attitudeValue':
            return 'getAttitudeValue'
        if self.skType == 'positionValue':
            return 'getPositionValue'
        raise ValueError("Invalid SignalK type {}".format(self.skType))

class TemplateGenerator(object):
    def __init__(self, templateFilename):
        self.templateFilename = templateFilename
        self.indentLevel = 0

    def p(self, line):
        self.content = self.content + " "*self.indentLevel + line + "\n"

    def generate(self, model, outputStream):
        self.content = ""
        data = self.beginTemplate(open(self.templateFilename).read())
        for k in model.keys:
            self.generateForKey(k)
        data = data.replace("// INSERT GENERATED CODE HERE\n", self.content)
        data = self.finalizeTemplate(data)

        outputStream.write("// This file was automatically generated by sk-code-generator.py\n")
        outputStream.write("// DO NOT MODIFY! YOUR CHANGES WOULD BE OVERWRITTEN\n")
        outputStream.write("// Look at {} instead or modify the script\n".format(self.templateFilename))
        outputStream.write("// Generated on {}\n\n".format(datetime.datetime.now()))

        outputStream.write(data)

    def generateForKey(self, key):
        pass

    def beginTemplate(self, data):
        return data

    def finalizeTemplate(self, data):
        return data


class SKPathEnumGenerator(TemplateGenerator):
    def beginTemplate(self, data):
        self.nonIndexedKeys = ""
        self.indexedKeys = ""
        return data

    def generateForKey(self, k):
        if k.isIndexed():
            self.indexedKeys += "  " + k.enumKey() + ",\n"
        else:
            self.nonIndexedKeys += "  " + k.enumKey() + ",\n"

    def finalizeTemplate(self, data):
        data = data.replace("  // Insert Non-Indexed Keys Here\n", self.nonIndexedKeys)
        data = data.replace("  // Insert Indexed Keys Here\n", self.indexedKeys)
        return data


class SKPathToStringGenerator(TemplateGenerator):
    def generateForKey(self, k):
        self.indentLevel = 4;
        self.p("case " + k.enumKey() + ":")
        if not k.isIndexed():
            self.p("  path = \"" + k.getPath() + "\";")
        else:
            (prefix, suffix) = k.getPath().split('%%')
            self.p("  path = \"" + prefix + "\" + _index + \"" + suffix + "\";")
        self.p("  break;")


class SKUpdateSyntacticSugarGenerator(TemplateGenerator):
    def generateForKey(self, k):
        if not k.isIndexed():
            self.p("bool has{}() const {{".format(k.camelCasedPath()))
            self.p("  return hasPath(" + k.enumKey() + ");")
            self.p("};")

            self.p("{} get{}() const {{".format(k.cType(), k.camelCasedPath()))
            self.p("  return this->operator[]({}).{}();".format(k.enumKey(), k.cTypeAccessor()))
            self.p("};")

            self.p("bool set{}({} newValue) {{".format(k.camelCasedPath(), k.cType()))
            self.p("  return setValue({}, newValue);".format(k.enumKey()))
            self.p("};")
        else:
            self.p("bool has{}(String index) const {{".format(k.camelCasedPath()))
            self.p("  return hasPath(SKPath(" + k.enumKey() + ", index));")
            self.p("};")

            self.p("{} get{}(String index) const {{".format(k.cType(), k.camelCasedPath()))
            self.p("  return this->operator[](SKPath({}, index)).{}();".format(k.enumKey(), k.cTypeAccessor()))
            self.p("};")

            self.p("bool set{}(String index, {} newValue) {{".format(k.camelCasedPath(), k.cType()))
            self.p("  return setValue(SKPath({}, index), newValue);".format(k.enumKey()))
            self.p("};")


class SKVisitorHeaderGenerator(TemplateGenerator):
    def generateForKey(self, k):
        self.indentLevel = 2;
        self.p("virtual void {}(const SKUpdate &u, const SKPath &p, const SKValue &v) {{}};".format(k.visitorName()))


class SKVisitorImplGenerator(TemplateGenerator):
    def generateForKey(self, k):
        self.indentLevel = 4;
        self.p("if (p.getStaticPath() == {}) {{".format(k.enumKey()))
        self.p("  {}(u, p, v);".format(k.visitorName()));
        self.p("}");


def main():
    parser = argparse.ArgumentParser()
    args = parser.parse_args()

    workPath = os.path.dirname(sys.argv[0])

    try:
        jsonModel = json.loads(open(os.path.join(workPath, 'signalk.json')).read())
        model = SKModel.model_from_json(jsonModel)
    except ValueError as e:
        print("Invalid SignalK Model description\n{}".format(e.message))
        return

    templatePath = workPath
    outputPath = workPath

    SKPathEnumGenerator(os.path.join(templatePath, 'SKPathEnum.h.tmpl')).generate(model, open(os.path.join(outputPath, 'SKPathEnum.generated.h'), 'w'))
    SKPathToStringGenerator(os.path.join(templatePath, 'SKPathToString.cpp.tmpl')).generate(model, open(os.path.join(outputPath, 'SKPathToString.generated.cpp'), 'w'))
    SKUpdateSyntacticSugarGenerator(os.path.join(templatePath, 'SKUpdateSyntacticSugar.h.tmpl')).generate(model, open(os.path.join(outputPath, 'SKUpdateSyntacticSugar.generated.h'), 'w'))
    SKVisitorHeaderGenerator(os.path.join(templatePath, 'SKVisitor.h.tmpl')).generate(model, open(os.path.join(outputPath, 'SKVisitor.generated.h'), 'w'))
    SKVisitorImplGenerator(os.path.join(templatePath, 'SKVisitor.cpp.tmpl')).generate(model, open(os.path.join(outputPath, 'SKVisitor.generated.cpp'), 'w'))

if __name__ == '__main__':
    main()
